

### redis的高性能原理？

1. 基于内存，减少了耗时的磁盘IO，采用了高效的数据结构
2. 单线程模型保证避免了多线程间的竞争，不会导致死锁，避免了线程切换带来的消耗
3. I/O多路复用机制，一个线程中连接了多个io流，监听和连接了多个socket

### 项目中用到了哪些设计模式？

- 策略模式：将一系列算法封装成对象，这些算法可以相互替换，这些算法可以独立于使用者，二使用者可以选择不同的策略，可以在运行时动态切换不同策略

  ```java
  // 策略接口
  interface CallbackStrategy {
      void executeCallback();
  }
  
  // 具体策略类
  class CustomerACallback implements CallbackStrategy {
      @Override
      public void executeCallback() {
          // 实现客户A的回调逻辑
      }
  }
  
  class CustomerBCallback implements CallbackStrategy {
      @Override
      public void executeCallback() {
          // 实现客户B的回调逻辑
      }
  }
  
  // 上下文类
  class CallbackContext {
      private CallbackStrategy strategy;
  
      public void setStrategy(CallbackStrategy strategy) {
          this.strategy = strategy;
      }
  
      public void executeCallback() {
          if (strategy != null) {
              strategy.executeCallback();
          }
      }
  }
  
  // 使用示例
  public class Main {
      public static void main(String[] args) {
          CallbackContext context = new CallbackContext();
          
          // 设置不同的策略
          context.setStrategy(new CustomerACallback());
          context.executeCallback(); // 执行客户A的回调逻辑
          
          context.setStrategy(new CustomerBCallback());
          context.executeCallback(); // 执行客户B的回调逻辑
      }
  }
  
  ```

  

### 相对于Redis，Redisson有哪些其他作用？

企业环境下不用自己实现锁，用Redisson框架，Redisson是Redis上各种分布式操作的客户端

1. 不可重入：比如A中获取锁了，A又调用B，B中又获取锁，就无法获取成功，造成死锁
2. 不可重试：获取锁失败没有重试机制 `trylock()`,等待时间内不断获取锁
3. 超时释放：过长时间自动释放锁会给执行时间很长的业务造成安全隐患
4. 主从一致性：主节点获取锁，尚未同步，主节点宕机，则新的主节点上无锁，就会导致多个线程拿到锁

### Redis如何实现分布式锁？

- set lock thread1 NX EX 10 不可重入

### 如何实现不可重入？

引入计时器，在获取锁时判断持锁者是否为当前线程，若为，计数器加一

### 如何实现自动续期？

未指定锁超时时间时，引入WatchDog,每10s更新一次，新时间为30s

### AOP是什么？

AOP是将一些具有共性的、不影响业务的非业务代码抽象出去，把这些定义在切面类中，做到核心业务与非核心业务代码的解耦合，使用动态代理机制实现

### AOP的设计模式？

- 代理模式：创造一个代理对象，将切面类中的方法逻辑织入到业务类当中，最后在代理对象的方法中调用业务类的方法

- 策略模式：Spring AOP有jdk代理和cglib动态代理两种方式

  ![image-20240312162542677](C:\Users\35114\AppData\Roaming\Typora\typora-user-images\image-20240312162542677.png)

  - JDK 动态代理只能为实现了接口的类生成代理对象，它要求目标对象必须实现至少一个接口。而 CGLIB 代理则可以为没有实现接口的类生成代理对象，它通过继承目标类并重写方法来实现代理。
  - JDK 动态代理是在运行时通过 Proxy 类动态生成代理类，然后通过反射创建代理对象。而 CGLIB 代理是在运行时通过 Enhancer 类动态生成代理类的字节码，并通过类加载器加载生成的代理类，最后实例化代理对象，它是把代理对象类的class文件加载进来，通过修改其字节码生成子类来处理

- 责任链模式

### AOP在哪些情况下会失效？

- static方法，为类所有，不是实例级别
- 当前对象没有被容器所管理，比如说忘了加`@Component`注解
- **Transactional注解**：在使用@Transactional注解进行事务管理时，如果在同一个类中的方法调用另一个带有@Transactional注解的方法，那么内部调用可能不会触发AOP代理，因为默认使用的是this引用而不是代理对象。

### 四层网络模型？

- 应用层：应用层专注于为用户提供应用功能，将应用的数据发给传输层
- 传输层：传输层关注端对端的传输，TCP可靠，UDP不可靠，超过MSS会分片
- 网络层：MSS+IP头部，超过MTU则分片，负责将数据从一个设备转到另一个设备，IP地址，负责寻址和路由转发
- 链路层：MAC地址，实现两个直连设备的通信

### 谈一谈IOC

​    IOC其实是一种思想，我们一般情况下创建对象是要自己手动new的，而IOC的话讲创建对象的权利交给了容器，我们每次需要对象的时候就去容器里面去取。为什么要使用IOC呢？在简单情况下其实看不出来，担当我们的类开始变得复杂起来，有几十个属性，属性又依赖不同的类时，我们这时候再手动去创建对象，一层一层的去填它的构造函数的参数显然就不现实了。

​    IOC容器实际上上是一个map，它的key是bean的名称，value就是bean，也就是这个类的实例对象

### 快排的思想？怎么优化快排？时间复杂度？

- 快排：选取一个基准，大于这个基准的数移到基准右边，小于这个基准的数移到基准左边，在递归的对左右两个字数组进行快排
- 时间复杂度：最好nlogn，最坏n*2
- 优化：随机选取基准避免元素本身有序时间复杂度过高；子数组规模较小时选用插入排序等简单算法；双路快排，即用两个指针扫描，小的交换到左边，大的交换到右边

### ArrayList扩容机制？

- ArrayList可以指定初始容量大小，不指定的话默认为10
- 也就是说，当我们向ArrayList中添加元素，达到我们指定的容量大小时，就会触发扩容
- 扩容的过程是创建一个长度为原数组长度1.5倍的数组，然后调用Arrays.Copyof方法将老数组中的值复制到新数组当中去，再将新值添加到新数组中；数组再满了就继续重复这个过程

### Zset底层怎么实现的？

zset采用了两种实现方式，跳表和压缩链表

当元素个数大于128或者元素长度大于64时就会转为skipList

### HashMap是线程安全的吗？为什么？有哪些实现线程安全的方法？

- HashMap不是线程安全的，在进行put操作时，可能出现一个线程先把值放入桶中，另一个线程又把它的值放入桶中，导致后面一个现成的值覆盖掉前面线程的值；另外，JDK1.7版本前HashMap扩容时采用的是头插法，肯能会导致循环链表的产生，造成死循环。还有一种情况，就是当一个线程中对map进行扩容操作时，另一个线程调用get方法，但扩容时元素可能没有落到原先的那个桶，导致get到nul值。
- 可以使用ConcurrentHashMap，也可以在每个使用了HashMap的方法前用syncronized关键字进行修饰

### 有哪些线程安全的集合？

- ConcurrentHashMap && HashTable
- BlockingQueue

### Mysql在哪些情况下会失效？

- 范围查询
- 左模糊匹配
- 不满足最左匹配原则
- 使用函数
- 使用运算
- or两边都要是索引

### 说一下最左匹配原则？

顾名思义，以最左边的为起点人很连续的索引都能匹配上，遇到范围查询停止

### 依赖注入有哪些注解？区别是什么？

常用的有@Autowired和@Resource

@Autowired是Spring定义的注解，而@Resource是JDK定义的，两者都可用来做注入

前者默认byType，后者默认byName

如果前者1个接口有两个实现类，则按照name去匹配，也可以通过@Qualifier显示的指定name

前者可作用在成员变量、方法、构造方法上，后者不支持构造方法

### Syncronized和ReentrantLock有什么区别

两者都是可重入锁

- 前者不可中断，后者可以响应中断，避免死锁
- 后者可以指定公平锁，前者是非公平锁，公平锁就是先等待的线程先执行
- 前者自动释放锁，后者需要手动释放锁
- 前者作用于对象、方法、代码块上，后者只作用于代码块
- 前者通过Monitor来实现，后者通过AQS来实现

### Full GC和 Young GC发生的时机

- Young GC:小的对象在分配空间时会被分配到Eden区，当Eden区没有足够的空间分配时就会触发一次Young GC，存货的对象会进入s0区，年龄被初始化为1，对象每存活一次年龄就会+1，达到一定值（默认15）时就会被移到老年区当中
- Full GC:当准备出发一次Young GC时，发现平均晋升空间比老年代的空余空间要大，则转触发Young GC为触发Full GC，对堆和方法区进行垃圾回收。除此之外，在永久代想要申请空间发现空间不足时，也会触发一次Full GC；调用System.gc()也会触发Full GC

### Spring是如何解决循环依赖的？

循环依赖则是指A对象的创立依赖于B对象，B对象的创立又依赖于A对象

Spring为了解决循环依赖，引入了三级缓存

这三级缓存本质上都是Map，一级缓存存放已经完全构建好的单例对象，也就是单例池；而二级缓存中存放经过实例化、但没有经过依赖注入、初始化的对象；第三级缓存则用于存放ObjectFactory

Spring在创建对象时，首先去一级缓存（单例池）中寻找对象是否被创建，如果找到了就返回；没找到且当前对象处于创建中状态时就去二级缓存中找，如果找到了，Spring 将返回提前曝光的bean实例，并尝试将这个bean初始化；如果还是没找到就从三级缓存中ObjectFactory.getObject方法获取，获取到了就从三级缓存移向二级缓存。

说A、B互相依赖的创建过程

### 使用Mysql索引要注意的事项

- 创建时机：我们使用索引主要是为了提高查询的效率，因此我们应该注意创建索引的时机。

  - 什么情况下应该创建索引，什么情况下不该创建索引呢？

  - 一般来说，我们需要对where查询频繁的字段创建索引，对具有唯一性的字段创建索引（如商品的id)，或者对经常进行Group By、order by的字段创建索引，这样能避免文件排序
  - 什么时候不需要创建索引呢，在where查询、group by、order by里用不上的字段，我们创建索引的主要目的是提高查询效率，如果这个字段在上述场景中出现都不频繁，那不仅起不到提高效率的作用，还会占用大量物理空间；除此之外，当字段中出现大量重复数据，如性别这个字段，只有男女，如果这个字段在数据库中分布均匀，Mysql的优化器在查询优化时不会走索引；对于经常更新的字段也不需要创建索引，因为这个过程会涉及到B+树维护自身结构，增加性能开销

- 避免失效：使用索引时要避免索引失效

  - 最左匹配法则
  - 左模糊匹配
  - 做运算
  - 使用函数
  - 范围查询
  - where的or前后都要是索引列

### HashMap的put方法

分为1.7和1.8版本去阐述

- 1.7

  - size==0? --> inflateTable
  - key==null?
  - key或null为键是否存在？
  - 是否需要扩容？

- 1.8

  - size==0? -->resize
  - 计算key: hashcode经过扰动函数处理后，hash&(n-1)[为什么长度是2的幂次方]
  - key存在？
  - 头结点存在且不相同-->红黑树 or 链表？
  - 链表：循环遍历，尾插法，（>64&&>=8转树）

  最后要判断是否需要扩容

### ConcurrentHashMap

- 1.7
  - Segement数组（继承了ReentrantLock)
  - 每个段都是一个HashEntry数组
  - 16个segement的并发度
- 1.8
  - syncornized锁住node
  - 链表/红黑树
  - node数量即为并发度

### 对象头都有什么内容

- 自身的运行数据
  - 分代age
  - hashcode
  - 锁状态
- 类型指针

### CMS

CMS即Concurrent Mark sweep，是第一款真正意义上的用户线程和GC线程并发的垃圾回收器，从他的名字可以看出，它采用的是标记-清除算法，主要用于回收老年代的垃圾。

- 初始标记:STW,标记GC root直接相关联的对象
- 并发标记：GC和用户线程并发，依照可达性分析的原则进行标记，再次过程中会跟踪用户产生的新的引用
- 重复标记：STW，标记刚才刚总的新引用
- 并发清除：GC与用户并发

优点：关注用户使用体验，停顿时间短

缺点：会导致大量内存碎片

### 线程池的创建方式

- Executor框架的Executors类：有界
- ThreadPoolExecutor

### Mysql为什么使用B+树索引

- 二分搜索：退化
- AVL/红黑树：树的高度（I/O次数），旋转操作
- B树：
  - B+非叶子节点仅存索引，不存数据，相同数据量情况下B+更矮胖，I/O更少
  - 范围查询：B要中序遍历，效率低
  - B增删效率低下

### 分库

- 垂直：按业务分库
- 水平：将一个表按规则分成不同的库

### Explain重点关注什么？

- type
  - all:全表
  - Index:全索引
  - range:索引范围查询（>)
  - ref：非唯一索引扫描
  - eq_ref：唯一索引扫描
  - const:主键/常量
- extra
  - using filesort
  - using temporary
  - using index:用了覆盖索引，无需回表

### 事务有哪些特性？

- A：原子性，要么都完成，要么都不完成，没有中间的状态，举例转账
- C：一致性：事务操作前后，数据满足完整性约束，数据库保持一致状态，举例转账
- I：隔离性：数据库允许多个事务对数据进行并发访问和修改的能力，防止多个事务执行时由于交叉执行造成的数据不一致，消费者购买这个商品，是不影响其他事务的
- D：持久性：事务结束后，对数据的修改是永远的，即使故障了也不会丢失

### AOF写回策略

AOF写回的过程：server_aof_buffer-->内核缓冲区-->硬盘

协会策略指的是从内核缓冲区写入硬盘的时机，也就是调用fsync的时机

- Always：影响主线程性能
- Everysec：折中
- No：数据丢失不确定

### AOF重写？

随着AOF文件的增大，加载AOF文件到内存时开销也会增大，于是重写AOF，把里面的多条语句合并成一条。最秒的是让数据只保持最新的状态，比如说我对某个数据进行了多次修改，只保留最新的那一次数据。这样做既缩小了AOF文件的大小，又能加快加载速度

### RDB两种方式

快照是某个时间的Redis的实际数据的副本

- save：阻塞主线程
- bgsave:fork出一个子线程进行快照

### AOF混合RDB

在每次AOF文件的开头都写入RDB快照，这样加载的速度快，也能使得数据更少的丢失

### 线程池的种类有哪些？

通过Executors类创建

- FixedThreadPool：创建一个线程数量固定的线程池，LinkedBlockingQueue，核心线程数=最大线程数，任务队列永远不会被放满
- SingleThreadExecutor:创建一个只有单线程的线程池
- CachedThreadPool：创建一个线程数量可以调整的线程池，SynchronousQueue
- SceduledThreadPool:返回一个用来在给定时间延迟后执行任务或定期执行任务的线程池，DelayedWorkQueue,按延长的任务时间长短排序

### 线程池有哪些拒绝策略？

- 直接丢弃
- 抛出异常
- 丢弃最久未执行的任务
- 将任务回退给调用者，使用调用者的线程执行

### 线程池参数怎么设置？

过大会增加线程上下文切换开销，过小则导致大量任务进入工作队列，甚至可能导致OOM

线程等待的时间越久，越需要多线程（充分利用CPU资源）；线程工作时间越久，越需要少线程

- CPU密集：n+1，多出来的一个可以充分利用线程中断带来的CPU资源空闲
- IO密集：2n，大部分的时间用于IO操作，不会占用CPU资源，因此可以让更多的线程工作

### 面试

- 自我介绍

  - 在xxx实习
  - 说我擅长xxx的八股文

- 实习

  - 我们组开发的是一个流程端的系统，包括对接用户啊，我们组是整个分期支付的入口，然后我们要串起各种各样的流程，包括支付啊、对账啊、核算，都是由我们串起这个流程。

  - 先介绍项目的背景，我们信贷类分为消费贷和现金贷，我们做的这个产品就属于消费贷，现金贷就比如说支付宝的借呗，现金贷就比如说支付宝的花呗，就他只能用来购物，用来买东西，他不能把钱套出来。我们做的是消费贷，就比如说有的购物公司他们没有自己的风控能力、或者没有信贷牌照啊，我这边呢，公司就跟他们进行合作，利息分成一部分。

  - 后续介绍做了什么：我们做的系统是一个流程系统，提供授信、借款、还款这些API接口嘛，然后我们的流程就是串起整个业务流程来，比如说我们作为入口端就需要串起来这些风控啊、核算啊这些系统的

  - 介绍自己做的：我们这个系统在我来之前就已经开发完成了，他是对接多个客户嘛，不同的客户就是传入的参数包括一些信息可能是不一样的，比如说易支付和得物，他们数据入参呢有一些合规性的要求，导致他们不能传某个参数，这些都是提前对应好的，我做的呢，就是把这些已经对应好的接口进行一系列适配。我主要负责授信这块

  - 肯定会问我授信（获取信用评级）内部有什么逻辑：授信就是能借多少钱、能借多少期、信用的利率之类的。授信会涉及到撞库和夺权，夺权就是比如说这个手机号绑定了另一个人，然后他现在要绑定一个新的人，就需要进行一些列验证嘛，然后把这个手机号抢过来归他了，然后就是数据的落表。我做的就是相当于对接了一个新客户，对这个流程的改造，比如说易支付不能传某些参数我就把他在校验上去掉，或者在校验上跳过；撞库就是指用户他可能之前借过，比如他现在在得物这个平台借钱，但是他之前在易支付借过，那库里就有了他的信息吗，那我就不用再去走一遍初始化的流程，就像身份证这些数据都不会变。接口是异步的，风控有结果通知到我，我要去调用它的接口，然后再去返回给客户，我存在数据库里的只能是md5

  - 技术亮点：AOP+配置文件咋做的，上线之前新版本没有线上验证过，假如贸然上线可能会造成比较大的问题，所以就采取在一部分服务器上小范围的上线嘛。我的组长就想着可以做一个灰度发布的工具，让实习生来做就可以，通过改配置文件，来实现灰度流量的控制，让我来做。我想了下，当时就去问了同事，同事就说可以用AOP啊，把if-else的那一套逻辑放在AOP里面来做，就是加一个切面吗，然后统一来控制

  - 策略模式适配多客户回调：领导让我改回调，我觉得加一个公司就加一段代码很麻烦，我就觉得这种业务场景就天然的适配策略模式，（比如说得物要求什么什么格式，易支付要求什么什么格式，加密算法也不一样，而有的公司他花钱少，或者说他没有提要求，那就用我默认的测略。那现在有这么多客户，我每加一个公司，就有加一段逻辑，这样就很麻烦，我不至于改一个用户的接口导致其他的不可用。）那我现在每加一个公司，就加一个策略，就完全降低了代码间的耦合度。

  - 解决sql：mentor是DBA，有一次查询很慢，mentor就把慢查询日志给到我。如果说是我昨天上的一条sql今天就很慢，那就是sql语句的问题；如果这条sql运行很久了，最近才出现问题，那可能就是数据出问题了，数据量激增啊之类的。如果是sql语句的问题的话，我就再去用explain来分析。看索引走没走，走的是不是想要的，会关注type（这个是最重要的），命中行数，走的索引

    - all
    - index]
    - range
    - ref
    - eq_ref
    - const

    如果一切都是最优了，那可能就是数据表的问题啊，就从技术或者业务上解决吗。技术解决起来太复杂就从业务上去做嘛

    不是数据问题就优化索引

  - 举例子：回表，某个表里索引是a,b,c，易支付某个字段（b)没有，他就只能查出a,c,b没有条件。然后发现b其实是个枚举类型，他借贷只有两种模式，分润和固收（分润就是双方分利润，固收就是固定收入），那就直接吧b给印上去，就能走覆盖索引了，就做了这个优化

  - 优化后看执行计划，看有没有慢查询日志出来，慢sql日志没了

  - 是否投入使用：投入使用，是创业比赛的一个项目，是师兄带我做的，我更多的是打杂，用docker部署都是我的师兄做的，商品表有哪些数据结构；redis做商品的缓存，没有必要，指导老师让我们加的，就是有技术亮点有经费，老师说有经费可以一起吃饭
  
  ### 乐观锁和悲观锁
  
  - 悲观锁假定对共享资源的访问一定会出现问题，比如说修改数据，在每次访问时都对数据加锁，加锁后其他线程被阻塞，直到锁释放为止
  - 乐观锁假设最好的情况，对共享资源的访问不会出现问题，不会加锁不会等待，只在提交的时候检查资源是否被修改过
    - CAS+版本号：自旋 V E N V==E允许重写
    - 版本号
  - 写多：悲观锁，防止每次失败重试带来的性能开销 读多：乐观锁，避免频繁枷锁影响性能
